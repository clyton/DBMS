1. Basic information
Team number : 29

#1 Student ID : 53649044 
#1 Student Name : Clyton Dantis 
OS (bit) : Linux Ubuntu 18.04 
gcc version : 5.4.0

#2 Student ID : 61167891 
#2 Student Name : Sandhya Chandramohan 
OS (bit) : MacOS High Sierra 10.13 
gcc version : 5.4.0


2. Catalog information about Index
- Show your catalog information about an index (tables, columns). 


3. Block Nested Loop Join (If you have implemented this feature)
- Describe how your block nested loop join works (especially, how you manage the given buffers.)
* steps
  1. leftMemBuf <- load the left table pages in memory using leftIn if rightIn has reached EOF
  2. If leftIn has reached end of file then return 
  3. rRec <- read next tuple from right table if cursor of leftMemBuf has reached end of buffer
  4. lRec <- cursor of leftMemBuf
  5. join lRec with rRec 
  6. if lRec join rRec satisfies condition
     1. jLR <- join lRec rRec
     2. advance cursor of leftMemBuf
     3. if on advancing cursor is invalid, read rRec <- read next tuple from rightIn
     4. set cursor of leftMemBuf to 0
     5. return success
  7. 


4. Index Nested Loop Join (If you have implemented this feature)
- Describe how your grace hash join works.


5. Grace Hash Join (If you have implemented this feature)
- Describe how your grace hash join works (especially, in-memory structure).
Not implemented

6. Aggregation
- Describe how your aggregation (basic, group-based hash) works.
Aggregation (Basic) -> 
- The scan iterator, the attibute over which we are performing the aggregation and the aggregate operator are stored as data members in the Aggregate class
- The iterator is used to call getNextTuple to read the tuple and get the value of the attribute over which we are performing the aggregation operation
- The iteration is performed till the end of file
- All aggregates (MAX, MIN, SUM, COUNT, AVERAGE) are calculated as float variables
- They are then returned in the output format, consisting of 1 byte of Null Indicator, followed by 4 bytes of float data

Aggregation (Group-based) -> Described below

7. Implementation Detail
- Have you added your own source file (.cc or .h)?
No

- Have you implemented any optional features? Then, describe them here.
Yes.
Aggregation (Group based hash) -> 
- The scan iterator, the attribute over which we are performing the aggregation, the attribute over which we are grouping the aggregation and the aggregate operators are stored as data members in the Aggregate class
- The grouped aggregates are stored as a map in the Aggregate class, with the key being the value of the groupBy attribute as a string and the value being the aggregate operations value for that group
- The getNextTuple returns the next pair from the map in the format of the output (1 byte null indicator + (length of string + string value if varchar) value)

- Other implementation details:
